* Wat
** Concurrency and Metaprogramming for JS
Wat is a tiny language with powerful concurrency and metaprogramming
features for embedding in JavaScript programs.

- Delimited continuations
  http://www.cs.indiana.edu/~dyb/pubs/monadicDC.pdf

- Delimited dynamic binding http://okmij.org/ftp/papers/DDBinding.pdf

- First-class lexical environments and fexprs
  http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf

- First-order control (sequential, conditional, loop, throw, catch,
  finally) running on JS stack

- Interop with JavaScript objects, functions, and callbacks

- JSON-based syntax for embedding Wat code in JavaScript

Wat is developed by Manuel Simoni (msimoni@gmail.com).
** Usage
*** Browser
#+begin_example
<html>
<head>
  <script type="text/javascript" src="wat.js"></script>
</head>
<body>
  <script type="text/javascript">
    var vm = new wat.VM();
    console.log(vm.run(["+", 1, 2]));
  </script>
</body>
</html>
#+end_example
*** Node.js
(require 'ob-js)
#+begin_src javascript :tangle test-wat.js
var wat = require("./wat.js");
var vm = new wat.VM();
vm.run(["+", 1, 2]);
#+end_src
** More documentation upcoming!
For now, follow http://axisofeval.blogspot.com/search/label/wat and/or
https://twitter.com/msimoni for updates.
** Notes about variable names
- [[http://axisofeval.blogspot.com/2011/08/notes-on-delimited-continuations.html][The Axis of Eval: Notes on delimited continuations]]
  - pushPrompt p e: p is a prompt, e is an expression.
  - withSubCont p f: p is a prompt, f is a function.
  - pushSubCont k e: k is a continuation, e is an expression.
- I believe that in cases e is an environment, in which case x is an
  expression.
- Evaluator Variable names
  - e = Environment
  - x = Expression
  - f = Function?
** Types
** Implementation
*** wat.js
**** CANCELLED Header
#+begin_src javascript :tangle wat.js
  (function(wat) {
  wat.VM = function() {
#+end_src
**** TODO Continuations and Frames [0/4]
- See Alexis King's talk for more about what those are.
***** TODO =TYPE= Continuation (fun, next, dbg, e)
- *Continuations are always made by [[id:15147b19-db9a-4f67-aed2-adacb186565a][captureFrame]].*
- [ ] fun = A function that takes two expressions and returns an ?.
- next = The expression to evaluate
- dbg = String to provide an error message for debugging
- e = The environment.
#+begin_src javascript :tangle wat.js
  function Continuation(fun, next, dbg, e) {
      this.fun = fun; this.next = next; this.dbg = dbg; this.e = e; }
  function isContinuation(x) { return x instanceof Continuation; }
#+end_src
***** TODO =FUNC= continueFrame(k, f)
- k = A continuation
- [ ] f = ?
- Returns the result of applying k.fun to k.next and f.
#+begin_src javascript :tangle wat.js
  function continueFrame(k, f) {
      return k.fun(k.next, f); }
#+end_src
***** TODO =TYPE= Capture (prompt, handler, k : Continuation)
- [ ] prompt = ?
- [ ] handler = ?
- k = A continuation
#+begin_src javascript :tangle wat.js
  function Capture(prompt, handler) {
      this.prompt = prompt; this.handler = handler; this.k = null; }
  function isCapture(x) { return x instanceof Capture; }
#+end_src
***** TODO =FUNC= captureFrame(capture, fun, dbg, e)
- Sets capture.k to a new continuation where
  - fun = fun
  - next = Old capture.k
  - dbg = dbg
  - e = e
#+begin_src javascript :tangle wat.js
  function captureFrame(capture, fun, dbg, e) {
      capture.k = new Continuation(fun, capture.k, dbg, e); }
#+end_src
**** TODO Evaluation Core [1/3]
***** TODO =FUNC= Evaluate(e, k, f, x) [0/1]
- e = Environment
- x = Expression to evaluate
- k = A Continuation
- [ ] f = ??
#+begin_src javascript :tangle wat.js
  function evaluate(e, k, f, x) {
      if (x && x.wat_eval)            // If x has its own evaluator
          return x.wat_eval(e, k, f); // Call it
      else return x;                  // Otherwise, x evaluates to itself
  }
#+end_src
***** DONE =TYPE= Sym (name)
- Symbols are wrappers around strings.
- Symbols evaluate to what they are bound to in the environment.
#+begin_src javascript :tangle wat.js
  function Sym(name) { this.name = name; }
  Sym.prototype.wat_eval = function(e, k, f) { return lookup(e, this.name); };
  Sym.prototype.toString = function() { return this.name; };
#+end_src
***** TODO Cons (A list) [2/3]
****** DONE =TYPE= Cons (car, cdr)
- A Cons cell has a car and a cdr.
#+begin_src javascript :tangle wat.js
  function Cons(car, cdr) { this.car = car; this.cdr = cdr; }
#+end_src
****** TODO =FUNC= wat_eval (e, k, f)
- Parameters
  - e = Environment
  - k = A continuation
  - [ ] f = ?
- To evaluate a list
  - [ ] A bunch of special cases for continuation stuff.
  - Evaluate the head of the list to get the operative.
  - Combine the operative with its arguments.
#+begin_src javascript :tangle wat.js
  Cons.prototype.wat_eval = function(e, k, f) {
      var op = isContinuation(k) ?             // If k is a continuation
          continueFrame(k, f)                  // the operator is the result of the continuation
          : evaluate(e, null, null, car(this)) // Else evaluate head of list to get operative
      if (isCapture(op)) {                             // If the operator is a Capture
          var that = this;                             // (Get around variable shadowing)
          captureFrame(                                // ???
              op,                                      // The Capture that is the operative
              function(k, f) {                         // fun = A function that returns
                  return that.wat_eval(e, k, f); },    //       the result of evaluating the list
              this,                                    // dbg = The list being evaluated
              e);                                      // Pass in the dynamic? environment
          return op;                                   // Return the modified Capture
      }
      return combine(e, null, null, op, cdr(this));    // 'Apply' the operative to its arguments
  };
#+end_src
****** DONE Printing
Lists are printed with their elements separated by spaces, surrounded
with paranthees.
#+begin_src javascript :tangle wat.js
  Cons.prototype.toString = function() { return "(" + cons_to_string(this) + ")" };
  function cons_to_string(cons) {
      if (cons.cdr !== NIL) {
          return to_string(cons.car) + " " + cons_to_string(cons.cdr);
      } else {
          return to_string(cons.car);
      }
  }
#+end_src
**** TODO Operative & Applicative Combiners [0/0]
- Combiners are what Wat calls functions.
- Combiners are split into two types:
  - Operatives do *not* evaluate their arguments
  - Applicatives do evaluation their arguments
    - Applicatives are wrappers for an underlying combiner.
    - They are applied by evaluating their arguments, then passing
      those to the underlying combiner.
- In Maru, things are the other way around
  - Functions evaluate their arguments by default.
  - A =<fixed>= wraps a function and prevents its arguments from being
    evaluated.
***** TODO =FUNC= combine (e, k, f, cmb, o) [0/1]
- combine 'applies' combiners.
- e = The environment
- k = A continuation
- [ ] f = ?
- cmb = The combiner to be 'applied'
- o = A tree of the combiner's arguments.
- combine just checks that cmb is a combiner, the delegates to cmb's
  own combine function.
#+begin_src javascript :tangle wat.js
  function combine(e, k, f, cmb, o) {
      if (cmb && cmb.wat_combine)             // Make sure cmb is a combiner
          return cmb.wat_combine(e, k, f, o); // Delegate to cmb's combine function
      else
          return fail("not a combiner: " + to_string(cmb));
  }
#+end_src
***** DONE =TYPE= Opv (p, ep, x, e)
- =Opv= creates a new operative.
  - p  = Formal parameters
  - ep = Formal parameter of dynamic environment
  - x  = Body of the operative
  - e  = Static lexical environment of the operative
- Operatives are printed as [Opv p ep x].
#+begin_src javascript :tangle wat.js
  function Opv(p, ep, x, e) { this.p = p; this.ep = ep; this.x = x; this.e = e; }
  Opv.prototype.toString = function() {
      return "[Opv " + to_string(this.p) + " " + to_string(this.ep) + " " + to_string(this.x) + "]";
  };
#+end_src
***** DONE =TYPE= Apv (cmb)
- Creates an applicative by wrapping a combiner.
- cmb = A combiner.
- Applicatives are printed as [Apv combiner].
#+begin_src javascript :tangle wat.js
  function Apv(cmb) { this.cmb = cmb; }
  Apv.prototype.toString = function() { return "[Apv " + to_string(this.cmb) + "]"; };
#+end_src
***** DONE Wrapping and Unwrapping =Apv=
- =wrap= wraps a combiner with an applicative.
- =unwrap= takes an applicative and returns the underlying combiner.
#+begin_src javascript :tangle wat.js
  function wrap(cmb) { return new Apv(cmb); };
  function unwrap(apv) { return apv.cmb; }
#+end_src
***** TODO =FUNC= Opv.wat_combine (e, k, f, o)
- =Opv.wat_combine= combines (applies) a operative with its arguments.
- Parameters
  - e = A dynamic environment.
  - k = A continuation
  - [ ] f = ?
  - o = A tree of arguments
- Local variables
  - xe =
  - pCap = An environment with the formal parametrs bount to the arguments
  - epCap = An environment with the formal parameter of the dynamic
    evironment bound the current dynamic environment.
- Fields of =Opv=
  - p = A tree of formal parameters
  - ep = The formal parameter of the dynamic environment
  - x = Body of the operative
  - e = Static lexical environment of the operator.
#+begin_src javascript :tangle wat.js
  Opv.prototype.wat_combine = function(e, k, f, o) {
      var xe = make_env(this.e);          // Create a new environment to evaluate the operative in
      var pCap = bind(xe, this.p, o);     // Bind the formal parameters to the arguments
      if (isCapture(pCap)) return pCap;   // If pCap is a Capture, return it
      var epCap = bind(xe, this.ep, e);   // Bind the dynamic environment to its formal parameter
      if (isCapture(epCap)) return epCap; // If eCap is a Capture, return it
      return evaluate(                    // Evaluate the body of the operator in the new environment.
          xe,                             // The environment with the operators formal parameters bound
          k,                              // Pass in k
          f,                              // Pass in f
          this.x                          // The body of the operative
      );
  };
#+end_src
***** TODO =FUNC= Apv.wat_combine (e, k, f, o)
- =Apv.wat_combine= applies a applicative to its arguments.
- Parameters
  - e = A dynamic environment.
  - k = A continuation
  - [ ] f = ?
  - o = A tree of arguments
#+begin_src javascript :tangle wat.js
  Apv.prototype.wat_combine = function(e, k, f, o) {
      var args =                          // Holds the result of evaluating the arguments
          isContinuation(k) ?             // If k is a continuation,
          continueFrame(k, f) :           // run the continuation?
          evalArgs(e, null, null, o, NIL) // otherwise evaluate the arguments
      if (isCapture(args)) {                             // If args is a Capture
          var that = this;                               // (Get around variable shadowing)
          captureFrame(                                  // ???
              args,                                      // The Capture is the arguments
              function(k, f) {                           // fun = A function that returns
                  return that.wat_combine(e, k, f, o);}, //       the relsult op 'applying' the operator
              cons(this, o),                             // dbg = "(Applicative arguments)"
              e);                                        // Pass in the dynamic? environment

          return args;                                   // Return the modified Capture
      }

      // Combine the underlying combiner with the evaluated arguments
      return this.cmb.wat_combine(e, null, null, args);
  };
#+end_src
***** TODO =FUNC= evalArgs (e, k, f, todo, done)
- Parameters
  - e = Environment
  - k = A Continuation
  - [ ] f = ?
  - todo = Arguments that still need to be evaluated
  - done = Arguments that have been evaluated
- [ ] Why not swap arg and done in the last return statement so the
  =reverse_list= in the first return statement isn't needed?
#+begin_src javascript :tangle wat.js
  function evalArgs(e, k, f, todo, done) {
      if (todo === NIL) {            // If the last argument has been evaluated
          return reverse_list(done); // Return the evaluated arguments in the right order.
      }
      if (isContinuation(k)) {                             // If k is a continuation
          var arg = continueFrame(k, f);                   // Run the continuation?
      } else {                                             // If k is not a continuation
          var arg = evaluate(e, null, null, car(todo));    // Evaluate the first unevaluated argument
      }
      if (isCapture(arg)) {                                // Needed to avoid variable capture
          captureFrame(                                    // ???
              arg,                                         // capture
              function(k, f) {                             // fun
                  return evalArgs(e, k, f, todo, done); }, // A recursive call to the outer function here
              car(todo),                                   // dbg = the argument being evaluated
              e);                                          // Pass in the dynamic environment

          return arg;                                      // What is arg now?
      }

      // Drop the head of todo as its just been evaluated.
      // Prepend the evaluated argument to done.
      // Recurse to process the rest of the arguments
      return evalArgs(e, null, null, cdr(todo), cons(arg, done));
  }
#+end_src
**** TODO Built-in Combiners [0/3]
***** TODO __Vau
#+begin_src javascript :tangle wat.js
  function __Vau() {}; function Def() {}; function Eval() {}
  __Vau.prototype.toString = function() { return "vau"; };
  __Vau.prototype.wat_combine = function(e, k, f, o) {
      return new Opv(elt(o, 0), elt(o, 1), elt(o, 2), e); };
#+end_src
***** TODO Def
#+begin_src javascript :tangle wat.js
  Def.prototype.toString = function() { return "def"; };
  Def.prototype.wat_combine = function self(e, k, f, o) {
      var lhs = elt(o, 0); if (isCapture(lhs)) return lhs;
      var rhs = elt(o, 1); if (isCapture(rhs)) return rhs;
      if (isContinuation(k)) {
          var val = continueFrame(k, f);
      } else {
          var val = evaluate(e, null, null, rhs);
      }
      if (isCapture(val)) {
          captureFrame(val, function(k, f) { return self(e, k, f, o); }, rhs, e);
          return val;
      }
      return bind(e, lhs, val);
  };
#+end_src
***** TODO Eval
#+begin_src javascript :tangle wat.js
  Eval.prototype.toString = function() { return "eval"; };
  Eval.prototype.wat_combine = function(e, k, f, o) {
      var x = elt(o, 0); if (isCapture(x)) return x;
      var e = elt(o, 1); if (isCapture(e)) return e;
      return evaluate(e, k, f, x); };
#+end_src
**** CANCELLED First-order Control
#+begin_src javascript :tangle wat.js
  function Begin() {}; function If() {}; function __Loop() {}
  function __Catch() {}; function Finally() {}
  Begin.prototype.toString = function() { return "begin"; };
  If.prototype.toString = function() { return "if"; };
  __Loop.prototype.toString = function() { return "loop"; };
  __Catch.prototype.toString = function() { return "catch"; };
  Finally.prototype.toString = function() { return "finally"; };
  Begin.prototype.wat_combine = function(e, k, f, o) {
      if (o === NIL) return null; else return begin(e, k, f, o); };
  function begin(e, k, f, xs) {
      if (isContinuation(k)) {
          var res = continueFrame(k, f);
      } else {
          var res = evaluate(e, null, null, car(xs));
      }
      if (isCapture(res)) {
          captureFrame(res, function(k, f) { return begin(e, k, f, xs); }, car(xs), e);
          return res;
      }
      var kdr = cdr(xs);
      if (kdr === NIL) return res; else return begin(e, null, null, kdr);
  }
  If.prototype.wat_combine = function self(e, k, f, o) {
      if (isContinuation(k)) {
          var test = continueFrame(k, f);
      } else {
          var test = evaluate(e, null, null, elt(o, 0));
      }
      if (isCapture(test)) {
          captureFrame(test, function(k, f) { return self(e, k, f, o); }, elt(o, 0), e);
          return test;
      }
      return evaluate(e, null, null, test ? elt(o, 1) : elt(o, 2));
  };
  __Loop.prototype.wat_combine = function self(e, k, f, o) {
      var first = true; // only continue once
      while (true) {
          if (first && isContinuation(k)) {
              var res = continueFrame(k, f);
          } else {
              var res = evaluate(e, null, null, elt(o, 0));
          }
          first = false;
          if (isCapture(res)) {
              captureFrame(res, function(k, f) { return self(e, k, f, o); }, elt(o, 0), e);
              return res;
          }
      }
  };
  __Catch.prototype.wat_combine = function self(e, k, f, o) {
      var th = elt(o, 0);
      var handler = elt(o, 1);
      try {
          if (isContinuation(k)) {
              var res = continueFrame(k, f);
          } else {
              var res = combine(e, null, null, th, NIL);
          }
      } catch(exc) {
          // unwrap handler to prevent eval if exc is sym or cons
          var res = combine(e, null, null, unwrap(handler), list(exc));
      }
      if (isCapture(res)) {
          captureFrame(res, function(k, f) { return self(e, k, f, o); }, th, e);
          return res;
      } else {
          return res;
      }
  };
  Finally.prototype.wat_combine = function self(e, k, f, o) {
      var prot = elt(o, 0);
      var cleanup = elt(o, 1);
      try {
          if (isContinuation(k)) {
              var res = continueFrame(k, f);
          } else {
              var res = evaluate(e, null, null, prot);
          }
          if (isCapture(res)) {
              captureFrame(res, function(k, f) { return self(e, k, f, o); }, prot, e);
          }
      } finally {
          if (isCapture(res)) {
              return res;
          } else {
              return doCleanup(e, null, null, cleanup, res);
          }
      }
  };
  function doCleanup(e, k, f, cleanup, res) {
      if (isContinuation(k)) {
          var fres = continueFrame(k, f);
      } else {
          var fres = evaluate(e, null, null, cleanup);
      }
      if (isCapture(fres)) {
          captureFrame(fres, function(k, f) { return doCleanup(e, k, f, cleanup, res); }, cleanup, e);
          return fres;
      } else {
          return res;
      }
  }
#+end_src
**** TODO Delimited Control [0/3]
***** TODO __PushPrompt
#+begin_src javascript :tangle wat.js
  function __PushPrompt() {};
  __PushPrompt.prototype.wat_combine = function self(e, k, f, o) {
      var prompt = elt(o, 0);
      var x = elt(o, 1);
      if (isContinuation(k)) {
          var res = continueFrame(k, f);
      } else {
          var res = evaluate(e, null, null, x);
      }
      if (isCapture(res)) {
          if (res.prompt === prompt) {
              var continuation = res.k;
              var handler = res.handler;
              return combine(e, null, null, handler, cons(continuation, NIL));
          } else {
              captureFrame(res, function(k, f) { return self(e, k, f, o); }, x, e);
              return res;
          }
      } else {
          return res;
      }
  };
#+end_src
***** TODO __TakeSubcont
#+begin_src javascript :tangle wat.js
 function __TakeSubcont() {};
  __TakeSubcont.prototype.wat_combine = function(e, k, f, o) {
      var prompt = elt(o, 0);
      var handler = elt(o, 1);
      var cap = new Capture(prompt, handler);
      captureFrame(cap, function(k, thef) { return combine(e, null, null, thef, NIL); }, this, e);
      return cap;
  };
 #+end_src
***** TODO __PushSubcont
#+begin_src javascript :tangle wat.js
 function __PushSubcont() {}
  __PushSubcont.prototype.wat_combine = function self(e, k, f, o) {
      var thek = elt(o, 0);
      var thef = elt(o, 1);
      if (isContinuation(k)) {
          var res = continueFrame(k, f);
      } else {
          var res = continueFrame(thek, thef);
      }
      if (isCapture(res)) {
          captureFrame(res, function(k, f) { return self(e, k, f, o); }, thef, e);
          return res;
      } else {
          return res;
      }
  };
#+end_src
**** TODO Dynamic Variables
#+begin_src javascript :tangle wat.js
  function DV(val) { this.val = val; }
  function DNew() {}; function DRef() {}; function __DLet() {}
  DNew.prototype.wat_combine = function(e, k, f, o) { return new DV(elt(o, 0)); };
  DRef.prototype.wat_combine = function(e, k, f, o) { return elt(o, 0).val; };
  __DLet.prototype.wat_combine = function self(e, k, f, o) {
      var dv = elt(o, 0);
      var val = elt(o, 1);
      var th = elt(o, 2);
      var oldVal = dv.val;
      dv.val = val;
      try {
          if (isContinuation(k)) {
              var res = continueFrame(k, f);
          } else {
              var res = combine(e, null, null, th, NIL);
          }
          if (isCapture(res)) {
              captureFrame(res, function(k, f) { return self(e, k, f, o); }, th, e);
              return res;
          } else {
              return res;
          }
      } finally {
          dv.val = oldVal;
      }
  };
#+end_src
**** TODO Objects
#+begin_src javascript :tangle wat.js
  function Nil() {}; var NIL = new Nil();
  Nil.prototype.toString = function() { return "()"; };
  function Ign() {}; var IGN = new Ign();
  Ign.prototype.toString = function() { return "#ignore"; };
  function cons(car, cdr) { return new Cons(car, cdr); }
  function car(cons) {
      if (cons instanceof Cons) return cons.car; else return fail("not a cons: " + to_string(cons)); }
  function cdr(cons) {
      if (cons instanceof Cons) return cons.cdr; else return fail("not a cons: " + to_string(cons)); }
  function elt(cons, i) { return (i === 0) ? car(cons) : elt(cdr(cons), i - 1); }
  function sym_name(sym) { return sym.name; }
  function Env(parent) { this.bindings = Object.create(parent ? parent.bindings : null); }
  function make_env(parent) { return new Env(parent); }
  function lookup(e, name) {
      if (name in e.bindings) return e.bindings[name];
      else return fail("unbound: " + name);
  }
  function bind(e, lhs, rhs) { return lhs.wat_match(e, rhs); }
  Sym.prototype.wat_match = function(e, rhs) {
      return e.bindings[this.name] = rhs; }
  Cons.prototype.wat_match = function(e, rhs) {
      var carCap = car(this).wat_match(e, car(rhs));
      if (isCapture(carCap)) return carCap;
      var cdrCap = cdr(this).wat_match(e, cdr(rhs));
      if (isCapture(cdrCap)) return cdrCap;
  };
  Nil.prototype.wat_match = function(e, rhs) {
      if (rhs !== NIL) return fail("NIL expected, but got: " + to_string(rhs)); };
  Ign.prototype.wat_match = function(e, rhs) {};
#+end_src
**** TODO Utilities
#+begin_src javascript :tangle wat.js
  var ROOT_PROMPT = new Sym("--root-prompt");
  function push_root_prompt(x) {
      return parse_json_value(["push-prompt", ["quote", ROOT_PROMPT], x]); }
  function fail(err) {
      var handler = jswrap(function(k) {
          do {
              console.log(k.dbg ? to_string(k.dbg) : "[unknown stack frame]", k.e.bindings);
          } while((k = k.next) !== null);
          throw err;
      });
      var cap = new Capture(ROOT_PROMPT, handler);
      captureFrame(cap, function(k, f) { throw "never reached"; }, "[error handler stack frame]", {});
      return cap;
  }
  function list() {
      return array_to_list(Array.prototype.slice.call(arguments)); }
  function list_star() {
      var len = arguments.length; var c = len >= 1 ? arguments[len-1] : NIL;
      for (var i = len-1; i > 0; i--) c = cons(arguments[i - 1], c); return c; }
  function array_to_list(array, end) {
      var c = end ? end : NIL;
      for (var i = array.length; i > 0; i--) c = cons(array[i - 1], c); return c; }
  function list_to_array(c) {
      var res = []; while(c !== NIL) { res.push(car(c)); c = cdr(c); } return res; }
  function reverse_list(list) {
      var res = NIL; while(list !== NIL) { res = cons(car(list), res); list = cdr(list); } return res; }
  function to_string(obj) {
      if ((obj !== null) && (obj !== undefined)) return obj.toString();
      else return Object.prototype.toString.call(obj); }
#+end_src
**** CANCELLED Parser
#+begin_src javascript :tangle wat.js
  function parse_json_value(obj) {
      switch(Object.prototype.toString.call(obj)) {
      case "[object String]": return obj === "#ignore" ? IGN : new Sym(obj);
      case "[object Array]": return parse_json_array(obj);
      default: return obj; } }
  function parse_json_array(arr) {
      var i = arr.indexOf("#rest");
      if (i === -1) return array_to_list(arr.map(parse_json_value));
      else { var front = arr.slice(0, i);
             return array_to_list(front.map(parse_json_value), parse_json_value(arr[i + 1])); } }
#+end_src
**** TODO JSNI
#+begin_src javascript :tangle wat.js
  function JSFun(jsfun) {
      if (Object.prototype.toString.call(jsfun) !== "[object Function]") return fail("no fun");
      this.jsfun = jsfun; }
  JSFun.prototype.wat_combine = function(e, k, f, o) {
      return this.jsfun.apply(null, list_to_array(o)); };
  JSFun.prototype.toString = function() { return "[JSFun " + this.jsfun.toString() + "]"; };
  function jswrap(jsfun) { return wrap(new JSFun(jsfun)); }
  function js_unop(op) { return jswrap(new Function("a", "return (" + op + " a)")); }
  function js_binop(op) { return jswrap(new Function("a", "b", "return (a " + op + " b)")); }
  function js_invoker(method_name) {
      return jswrap(function() {
          if (arguments.length < 1) return fail("invoker: " + arguments);
          var rcv = arguments[0];
          var method = rcv[method_name];
          return method.apply(rcv, Array.prototype.slice.call(arguments, 1));
      }); }
  function js_getter(prop_name) {
      return jswrap(function() {
          if (arguments.length !== 1) return fail("getter: " + arguments);
          var rcv = arguments[0];
          return rcv[prop_name];
      }); }
  function js_setter(prop_name) {
      return jswrap(function() {
          if (arguments.length !== 2) return fail("setter: " + arguments);
          var rcv = arguments[0];
          return rcv[prop_name] = arguments[1];
      }); }
  function js_callback(cmb) {
      return function() {
          var args = array_to_list(Array.prototype.slice.call(arguments));
          return evaluate(environment, null, null, push_root_prompt(cons(cmb, args)));
      } }
#+end_src
**** CANCELLED Primitives
#+begin_src javascript :tangle wat.js
  var primitives =
      ["begin",

       // Core

       // Fexprs
       ["def", "--vau", new __Vau()],
       ["def", "eval", wrap(new Eval())],
       ["def", "make-environment", jswrap(function() { return make_env(); })],
       ["def", "wrap", jswrap(wrap)],
       ["def", "unwrap", jswrap(unwrap)],
       // Values
       ["def", "cons", jswrap(cons)],
       ["def", "cons?", jswrap(function(obj) { return obj instanceof Cons; })],
       ["def", "nil?", jswrap(function(obj) { return obj === NIL; })],
       ["def", "symbol?", jswrap(function(obj) { return obj instanceof Sym; })],
       ["def", "symbol-name", jswrap(sym_name)],
       // First-order Control
       ["def", "if", new If()],
       ["def", "--loop", new __Loop()],
       ["def", "throw", jswrap(function(err) { throw err; })],
       ["def", "--catch", wrap(new __Catch())],
       ["def", "finally", new Finally()],
       // Delimited Control
       ["def", "--push-prompt", new __PushPrompt()],
       ["def", "--take-subcont", wrap(new __TakeSubcont())],
       ["def", "--push-subcont", wrap(new __PushSubcont())],
       // Dynamically-scoped Variables
       ["def", "dnew", wrap(new DNew())],
       ["def", "--dlet", wrap(new __DLet())],
       ["def", "dref", wrap(new DRef())],
       // JS Interface
       ["def", "js-wrap", jswrap(jswrap)],
       ["def", "js-unop", jswrap(js_unop)],
       ["def", "js-binop", jswrap(js_binop)],
       ["def", "js-getter", jswrap(js_getter)],
       ["def", "js-setter", jswrap(js_setter)],
       ["def", "js-invoker", jswrap(js_invoker)],
       ["def", "js-callback", jswrap(js_callback)],
       ["def", "list-to-array", jswrap(list_to_array)],
       ["def", "array-to-list", jswrap(array_to_list)],
       // Optimization
       ["def", "list*", jswrap(list_star)],

       // Primitives

       ["def", "quote", ["--vau", ["x"], "#ignore", "x"]],
       ["def", "list", ["wrap", ["--vau", "arglist", "#ignore", "arglist"]]],
       ["def", "string", ["--vau", ["sym"], "#ignore", ["symbol-name", "sym"]]],
       ["def", "get-current-environment", ["--vau", [], "e", "e"]],

       ["def", "make-macro-expander",
        ["wrap",
         ["--vau", ["expander"], "#ignore",
          ["--vau", "operands", "env",
           ["eval", ["eval", ["cons", "expander", "operands"], ["make-environment"]], "env"]]]]],

       ["def", "vau",
        ["make-macro-expander",
         ["--vau", ["params", "env-param", "#rest", "body"], "#ignore",
          ["list", "--vau", "params", "env-param", ["cons", "begin", "body"]]]]],

       ["def", "macro",
        ["make-macro-expander",
         ["vau", ["params", "#rest", "body"], "#ignore",
          ["list", "make-macro-expander", ["list*", "vau", "params", "#ignore", "body"]]]]],

       ["def", "lambda",
        ["macro", ["params", "#rest", "body"],
         ["list", "wrap", ["list*", "vau", "params", "#ignore", "body"]]]],
       ["def", "loop",
        ["macro", "body",
         ["list", "--loop", ["list*", "begin", "body"]]]],
       ["def", "catch",
        ["macro", ["protected", "handler"],
         ["list", "--catch", ["list", "lambda", [], "protected"], "handler"]]],

       ["def", "push-prompt",
        ["vau", ["prompt", "#rest", "body"], "e",
         ["eval", ["list", "--push-prompt", ["eval", "prompt", "e"], ["list*", "begin", "body"]], "e"]]],
       ["def", "take-subcont",
        ["macro", ["prompt", "k", "#rest", "body"],
         ["list", "--take-subcont", "prompt", ["list*", "lambda", ["list", "k"], "body"]]]],
       ["def", "push-subcont",
        ["macro", ["k", "#rest", "body"],
         ["list", "--push-subcont", "k", ["list*", "lambda", [], "body"]]]],

       ["def", "dlet",
        ["macro", ["dv", "val", "#rest", "body"],
         ["list", "--dlet", "dv", "val", ["list*", "lambda", [], "body"]]]],

       // JS

       ["def", "array", ["lambda", "args", ["list-to-array", "args"]]],

       ["def", "define-js-unop",
        ["macro", ["op"],
         ["list", "def", "op", ["list", "js-unop", ["list", "string", "op"]]]]],

       ["define-js-unop", "!"],
       ["define-js-unop", "typeof"],
       ["define-js-unop", "~"],

       ["def", "define-js-binop",
        ["macro", ["op"],
         ["list", "def", "op", ["list", "js-binop", ["list", "string", "op"]]]]],

       ["define-js-binop", "!="],
       ["define-js-binop", "!=="],
       ["define-js-binop", "%"],
       ["define-js-binop", "&"],
       ["define-js-binop", "&&"],
       ["define-js-binop", "*"],
       ["define-js-binop", "+"],
       ["define-js-binop", "-"],
       ["define-js-binop", "/"],
       ["define-js-binop", "<"],
       ["define-js-binop", "<<"],
       ["define-js-binop", "<="],
       ["define-js-binop", "=="],
       ["define-js-binop", "==="],
       ["define-js-binop", ">"],
       ["define-js-binop", ">>"],
       ["define-js-binop", ">>>"],
       ["define-js-binop", "^"],
       ["define-js-binop", "in"],
       ["define-js-binop", "instanceof"],
       ["define-js-binop", "|"],
       ["define-js-binop", "||"],

       ["def", ".",
        ["macro", ["field", "obj"],
         ["list", ["list", "js-getter", ["list", "string", "field"]], "obj"]]],

       ["def", "#",
        ["macro", ["method", "obj", "#rest", "args"],
         ["list*", ["list", "js-invoker", ["list", "string", "method"]], "obj", "args"]]],

      ];
#+end_src
**** TODO Init
#+begin_src javascript :tangle wat.js
  var environment = make_env();
  bind(environment, new Sym("def"), new Def());
  bind(environment, new Sym("begin"), new Begin());
  evaluate(environment, null, null, parse_json_value(primitives));
  /* API */
  function run(x) {
      var wrapped = push_root_prompt(parse_json_value(x));
      return evaluate(environment, null, null, wrapped);
  }
  return { "run": run };
#+end_src
**** CANCELLED Footer
#+begin_src javascript :tangle wat.js
  }
  })(typeof exports === "undefined" ? this["wat"] = {} : exports);
#+end_src
*** wat-basics.js
#+begin_src javascript :tangle wat-basics.js
  (function(wat_basics){
  wat_basics.main =
          ["begin",

           ["def", "compose",
            ["lambda", ["f", "g"], ["lambda", ["arg"], ["f", ["g", "arg"]]]]],

           ["def", "car", ["lambda", [["x", "#rest", "#ignore"]], "x"]],
           ["def", "cdr", ["lambda", [["#ignore", "#rest", "x"]], "x"]],
           ["def", "caar", ["compose", "car", "car"]],
           ["def", "cadr", ["compose", "car", "cdr"]],
           ["def", "cdar", ["compose", "cdr", "car"]],
           ["def", "cddr", ["compose", "cdr", "cdr"]],

           ["def", "define-macro",
            ["macro", [["name", "#rest", "params"], "#rest", "body"],
             ["list", "def", "name", ["list*", "macro", "params", "body"]]]],

           ["define-macro", ["define", "lhs", "#rest", "rhs"],
            ["if", ["cons?", "lhs"],
             ["list", "def", ["car", "lhs"], ["list*", "lambda", ["cdr", "lhs"], "rhs"]],
             ["list", "def", "lhs", ["car", "rhs"]]]],

           ["define", ["map-list", "f", "lst"],
             ["if", ["nil?", "lst"],
              [],
              ["cons", ["f", ["car", "lst"]], ["map-list", "f", ["cdr", "lst"]]]]],

           ["define-macro", ["let", "bindings", "#rest", "body"],
            ["cons",
             ["list*", "lambda", ["map-list", "car", "bindings"], "body"],
             ["map-list", "cadr", "bindings"]]],

           ["define-macro", ["let*", "bindings", "#rest", "body"],
            ["if", ["nil?", "bindings"],
             ["list*", "let", [], "body"],
             ["list", "let", ["list", ["car", "bindings"]],
              ["list*", "let*", ["cdr", "bindings"], "body"]]]],

           ["define-macro", ["where", "expr", "#rest", "bindings"],
            ["list", "let", "bindings", "expr"]],

           ["define-macro", ["where*", "expr", "#rest", "bindings"],
            ["list", "let*", "bindings", "expr"]],

           ["define", ["call-with-escape", "fun"],
            ["let", [["fresh", ["list", null]]],
             ["catch", ["fun", ["lambda", ["val"], ["throw", ["list", "fresh", "val"]]]],
              ["lambda", ["exc"],
               ["if", ["&&", ["cons?", "exc"], ["===", "fresh", ["car", "exc"]]],
                ["cadr", "exc"],
                ["throw", "exc"]]]]]],

           ["define-macro", ["let-escape", "name", "#rest", "body"],
            ["list", "call-with-escape", ["list*", "lambda", ["list", "name"], "body"]]],

           ["define", ["call-while", "test-fun", "body-fun"],
            ["let-escape", "return",
             ["loop",
              ["if", ["test-fun"],
               ["body-fun"],
               ["return", null]]]]],

           ["define-macro", ["while", "test", "#rest", "body"],
            ["list", "call-while",
             ["list", "lambda", [], "test"],
             ["list*", "lambda", [], "body"]]],

           ["def", "set!",
            ["vau", ["env", "lhs", "rhs"], "denv",
             ["eval",
              ["list", "def", "lhs",
               ["list", ["unwrap", "eval"], "rhs", "denv"]],
              ["eval", "env", "denv"]]]],

           ["define", ["apply", "appv", "arg"],
            ["eval", ["cons", ["unwrap", "appv"], "arg"], ["make-environment"]]]

          ];
  })(typeof exports === "undefined" ? this["wat_basics"] = {} : exports);
#+end_src
